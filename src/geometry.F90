module geometry

  use constants
  use error,                  only: fatal_error, warning
  use geometry_header,        only: Cell, Surface, Universe, Lattice
  use global
  use output,                 only: write_message
  use particle_header,        only: LocalCoord, deallocate_coord, Particle
  use particle_restart_write, only: write_particle_restart
  use string,                 only: to_str

  implicit none
     
contains

!===============================================================================
! SIMPLE_CELL_CONTAINS determines whether a given the current coordinates of the
! particle are inside a cell defined as the intersection of a series of surfaces
!===============================================================================

  function simple_cell_contains(c, p) result(in_cell)

    type(Cell),     pointer       :: c
    type(Particle), intent(inout) :: p
    logical                       :: in_cell

    integer :: i               ! index of surfaces in cell
    integer :: i_surface       ! index in surfaces array (with sign)
    logical :: specified_sense ! specified sense of surface in list
    logical :: actual_sense    ! sense of particle wrt surface
    type(Surface), pointer, save :: s => null()
!$omp threadprivate(s)

    SURFACE_LOOP: do i = 1, c % n_surfaces
      ! Lookup surface
      i_surface = c % surfaces(i)

      ! Check if the particle is currently on the specified surface
      if (i_surface == p % surface) then
        ! Particle is heading into the cell
        cycle
      elseif (i_surface == -p % surface) then
        ! Particle is heading out of the cell
        in_cell = .false.
        return
      end if

      ! Determine the specified sense of the surface in the cell and the actual
      ! sense of the particle with respect to the surface
      s => surfaces(abs(i_surface))
      actual_sense = sense(p, s)
      specified_sense = (c % surfaces(i) > 0)

      ! Compare sense of point to specified sense
      if (actual_sense .neqv. specified_sense) then
        in_cell = .false.
        return
      end if
    end do SURFACE_LOOP

    ! If we've reached here, then the sense matched on every surface
    in_cell = .true.

  end function simple_cell_contains


!===============================================================================
! CHECK_CELL_OVERLAP checks for overlapping cells at the current particle's
! position using simple_cell_contains and the LocalCoord's built up by find_cell
!===============================================================================

  subroutine check_cell_overlap(p)

    type(Particle), intent(inout) :: p

    integer :: i                       ! cell loop index on a level
    integer :: n                       ! number of cells to search on a level
    integer :: index_cell              ! index in cells array
    type(Cell),       pointer, save :: c => null()     ! pointer to cell
    type(Universe),   pointer, save :: univ => null()  ! universe to search in
    type(LocalCoord), pointer, save :: coord => null() ! particle coordinate to search on
!$omp threadprivate(c, univ, coord)

    coord => p % coord0

    ! loop through each coordinate level
    do while (associated(coord))

      p % coord => coord

      univ => universes(coord % universe)
      n = univ % n_cells

      ! loop through each cell on this level
      do i = 1, n
        index_cell = univ % cells(i)
        c => cells(index_cell)

        if (simple_cell_contains(c, p)) then
          ! the particle should only be contained in one cell per level
          if (index_cell /= coord % cell) then
            message = "Overlapping cells detected: " //               &
                      trim(to_str(cells(index_cell) % id)) // ", " // &
                      trim(to_str(cells(coord % cell) % id)) //       &
                      " on universe " // trim(to_str(univ % id))
            call fatal_error()
          end if

          overlap_check_cnt(index_cell) = overlap_check_cnt(index_cell) + 1

        end if

      end do

      coord => coord % next

    end do

  end subroutine check_cell_overlap

!===============================================================================
! FIND_CELL determines what cell a source particle is in within a particular
! universe. If the base universe is passed, the particle should be found as long
! as it's within the geometry
!===============================================================================

  recursive subroutine find_cell(p, found, search_cells)

    type(Particle), intent(inout) :: p
    logical,        intent(inout) :: found
    integer,        optional      :: search_cells(:)

    integer :: i                    ! index over cells
    integer :: i_x, i_y, i_z        ! indices in lattice
    integer :: n_x, n_y, n_z        ! size of lattice
    integer :: n                    ! number of cells to search
    integer :: index_cell           ! index in cells array
    real(8) :: xyz(3)               ! temporary location
    real(8) :: upper_right(3)       ! lattice upper_right
    logical :: use_search_cells     ! use cells provided as argument
    logical :: outside_lattice      ! if particle is not inside lattice bounds
    logical :: lattice_edge         ! if particle is on a lattice edge
    type(Cell),     pointer, save :: c => null()    ! pointer to cell
    type(Lattice),  pointer, save :: lat => null()  ! pointer to lattice
    type(Universe), pointer, save :: univ => null() ! universe to search in
!$omp threadprivate(c, lat, univ)

    ! Remove coordinates for any lower levels
    call deallocate_coord(p % coord % next)

    ! set size of list to search
    if (present(search_cells)) then
      use_search_cells = .true.
      n = size(search_cells)
    else
      use_search_cells = .false.
      univ => universes(p % coord % universe)
      n = univ % n_cells
    end if

    do i = 1, n
      ! select cells based on whether we are searching a universe or a provided
      ! list of cells (this would be for lists of neighbor cells)
      if (use_search_cells) then
        index_cell = search_cells(i)
        ! check to make sure search cell is in same universe
        if (cells(index_cell) % universe /= p % coord % universe) cycle
      else
        index_cell = univ % cells(i)
      end if

      ! get pointer to cell
      c => cells(index_cell)

      if (simple_cell_contains(c, p)) then
        ! Set cell on this level
        p % coord % cell = index_cell

        ! Show cell information on trace
        if (verbosity >= 10 .or. trace) then
          message = "    Entering cell " // trim(to_str(c % id))
          call write_message()
        end if

        if (c % type == CELL_NORMAL) then
          ! ====================================================================
          ! AT LOWEST UNIVERSE, TERMINATE SEARCH

          ! set material
          p % last_material = p % material
          p % material = c % material

        elseif (c % type == CELL_FILL) then
          ! ====================================================================
          ! CELL CONTAINS LOWER UNIVERSE, RECURSIVELY FIND CELL

          ! Create new level of coordinates
          allocate(p % coord % next)
          p % coord % next % xyz = p % coord % xyz
          p % coord % next % uvw = p % coord % uvw

          ! Move particle to next level and set universe
          p % coord => p % coord % next
          p % coord % universe = c % fill

          ! Apply translation
          if (allocated(c % translation)) then
            p % coord % xyz = p % coord % xyz - c % translation
          end if

          ! Apply rotation
          if (allocated(c % rotation)) then
            p % coord % xyz = matmul(c % rotation, p % coord % xyz)
            p % coord % uvw = matmul(c % rotation, p % coord % uvw)
            p % coord % rotated = .true.
          end if

          call find_cell(p, found)
          if (.not. found) exit

        elseif (c % type == CELL_LATTICE) then
          ! ====================================================================
          ! CELL CONTAINS LATTICE, RECURSIVELY FIND CELL

          ! Set current lattice
          lat => lattices(c % fill)

          outside_lattice = .false.
          lattice_edge = .false.

          ! determine lattice index based on position
          xyz = p % coord % xyz + TINY_BIT * p % coord % uvw
          i_x = ceiling((xyz(1) - lat % lower_left(1))/lat % width(1))
          i_y = ceiling((xyz(2) - lat % lower_left(2))/lat % width(2))
          n_x = lat % dimension(1)
          n_y = lat % dimension(2)
          if (lat % n_dimension == 3) then
            i_z = ceiling((xyz(3) - lat % lower_left(3))/lat % width(3))
            n_z = lat % dimension(3)
          else
            i_z = 1
            n_z = 1
          end if

          ! Check if lattice coordinates are within bounds
          if (i_x < 1 .or. i_x > n_x .or. i_y < 1 .or. i_y > n_y .or. &
               i_z < 1 .or. i_z > n_z) then

            ! Check for when particle is on lattice edge
            upper_right(1) = lat % lower_left(1) + &
                             lat % width(1) * dble(lat % dimension(1))
            upper_right(2) = lat % lower_left(2) + &
                             lat % width(2) * dble(lat % dimension(2))
            if ( abs(xyz(1) - lat % lower_left(1)) < FP_COINCIDENT .or. &
                 abs(xyz(2) - lat % lower_left(2)) < FP_COINCIDENT .or. &
                 abs(upper_right(1) - xyz(1)) < FP_COINCIDENT .or. &
                 abs(upper_right(2) - xyz(2)) < FP_COINCIDENT) then
              lattice_edge = .true.
            end if
            if (lat % n_dimension == 3) then
              upper_right(3) = lat % lower_left(3) + &
                               lat % width(3) * dble(lat % dimension(3))
              if (abs(xyz(3) - lat % lower_left(3)) < FP_COINCIDENT .or. &
                  abs(upper_right(3) - xyz(3)) < FP_COINCIDENT) then
                lattice_edge = .true.
              end if
            end if
            
            if (lattice_edge) then
              
              ! In this case the neutron is leaving the lattice, so we move it
              ! out, remove all lower coordinate levels and then search from
              ! universe 0.
            
              p % coord => p % coord0
              call deallocate_coord(p % coord % next)

              ! Reset surface and advance particle a tiny bit
              p % surface = NONE
              p % coord % xyz = xyz

            else

              ! We're outside the lattice, so treat this as a normal cell with
              ! the material specified for the outside

              outside_lattice = .true.
              p % last_material = p % material
              p % material = c % material

              ! We'll still make a new coordinate for the particle, as 
              ! distance_to_boundary will still need to track through lattice
              ! widths even though there's nothing in them but this material

            end if

          end if

          if (.not. lattice_edge) then

            ! Create new level of coordinates
            allocate(p % coord % next)

            ! adjust local position of particle
            p % coord % next % xyz(1) = p % coord % xyz(1) - &
                 (lat % lower_left(1) + (i_x - 0.5_8)*lat % width(1))
            p % coord % next % xyz(2) = p % coord % xyz(2) - &
                 (lat % lower_left(2) + (i_y - 0.5_8)*lat % width(2))
            if (lat % n_dimension == 3) then
              p % coord % next % xyz(3) = p % coord % xyz(3) - &
                 (lat % lower_left(3) + (i_z - 0.5_8)*lat % width(3))
            else
              p % coord % next % xyz(3) = p % coord % xyz(3)
            end if
            p % coord % next % uvw = p % coord % uvw

            ! set particle lattice indices
            p % coord % next% lattice   = c % fill
            p % coord % next% lattice_x = i_x
            p % coord % next% lattice_y = i_y
            p % coord % next% lattice_z = i_z
            if (.not. outside_lattice) then
              p % coord % next % universe = lat % universes(i_x,i_y,i_z)
            else

              ! Set universe as the same for subsequent calls to find_cell
              p % coord % next % universe = p % coord % universe

              ! Set coord cell for calls to distance_to_boundary
              p % coord % next % cell = index_cell

            end if

            ! Move particle to next level
            p % coord => p % coord % next

          end if

          if (.not. outside_lattice) then
            call find_cell(p, found)
            if (.not. found) exit
          end if

        end if

        ! Found cell so we can return
        found = .true.
        return
      end if
    end do

    found = .false.

  end subroutine find_cell

!===============================================================================
! CROSS_LATTICE moves a particle into a new lattice element
!===============================================================================

  subroutine cross_lattice(p, lattice_crossed)

    type(Particle), intent(inout) :: p
    integer,        intent(in)    :: lattice_crossed

    integer :: i_x, i_y, i_z ! indices in lattice
    integer :: n_x, n_y, n_z ! size of lattice
    real(8) :: x0, y0, z0    ! half width of lattice element
    logical :: found         ! particle found in cell?
    type(Lattice), pointer, save :: lat => null()
!$omp threadprivate(lat)

    lat => lattices(p % coord % lattice)

    if (verbosity >= 10 .or. trace) then
      message = "    Crossing lattice " // trim(to_str(lat % id)) // &
           ". Current position (" // trim(to_str(p % coord % lattice_x)) &
           // "," // trim(to_str(p % coord % lattice_y)) // "," // &
           trim(to_str(p % coord % lattice_z)) // ")"
      call write_message()
    end if

    if (lat % type == LATTICE_RECT) then
      x0 = lat % width(1) * 0.5_8
      y0 = lat % width(2) * 0.5_8
      if (lat % n_dimension == 3) z0 = lat % width(3) * 0.5_8

      select case (lattice_crossed)
      case (LATTICE_LEFT)
        ! Move particle to left element
        p % coord % lattice_x = p % coord % lattice_x - 1
        p % coord % xyz(1) = x0

      case (LATTICE_RIGHT)
        ! Move particle to right element
        p % coord % lattice_x = p % coord % lattice_x + 1
        p % coord % xyz(1) = -x0

      case (LATTICE_BACK)
        ! Move particle to bottom element
        p % coord % lattice_y = p % coord % lattice_y - 1
        p % coord % xyz(2) = y0

      case (LATTICE_FRONT)
        ! Move particle to top element
        p % coord % lattice_y = p % coord % lattice_y + 1
        p % coord % xyz(2) = -y0

      case (LATTICE_BOTTOM)
        ! Move particle to bottom element
        p % coord % lattice_z = p % coord % lattice_z - 1
        p % coord % xyz(3) = z0

      case (LATTICE_TOP)
        ! Move particle to top element
        p % coord % lattice_z = p % coord % lattice_z + 1
        p % coord % xyz(3) = -z0

      end select
    elseif (lat % type == LATTICE_HEX) then
      ! TODO: Add hex lattice support
    end if

    ! Check to make sure still in lattice
    i_x = p % coord % lattice_x
    i_y = p % coord % lattice_y
    i_z = p % coord % lattice_z
    n_x = lat % dimension(1)
    n_y = lat % dimension(2)
    if (lat % n_dimension == 3) then
      n_z = lat % dimension(3)
    else
      n_z = 1
    end if
    if (i_x < 1 .or. i_x > n_x .or. i_y < 1 .or. i_y > n_y .or. &
         i_z < 1 .or. i_z > n_z) then
      call deallocate_coord(p % coord0 % next)
      p % coord => p % coord0

      ! Search for particle
      call find_cell(p, found)
      if (.not. found) then
        message = "Could not locate particle " // trim(to_str(p % id)) // &
             " after crossing a lattice boundary."
        call handle_lost_particle(p)
        return
      end if
    else
      ! Find universe for next lattice element
      p % coord % universe = lat % universes(i_x, i_y, i_z)

      ! Find cell in next lattice element
      call find_cell(p, found)
      if (.not. found) then
        ! In some circumstances, a particle crossing the corner of a cell may not
        ! be able to be found in the next universe. In this scenario we cut off
        ! all lower-level coordinates and search from universe zero

        ! Remove lower coordinates
        call deallocate_coord(p % coord0 % next)
        p % coord => p % coord0

        ! Search for particle
        call find_cell(p, found)
        if (.not. found) then
          message = "Could not locate particle " // trim(to_str(p % id)) // &
               " after crossing a lattice boundary."
          call handle_lost_particle(p)
          return
        end if
      end if
    end if

  end subroutine cross_lattice

!===============================================================================
! DISTANCE_TO_BOUNDARY calculates the distance to the nearest boundary for a
! particle 'p' traveling in a certain direction. For a cell in a subuniverse
! that has a parent cell, also include the surfaces of the edge of the universe.
!===============================================================================

  subroutine distance_to_boundary(p, dist, surface_crossed, lattice_crossed)

    type(Particle), intent(inout) :: p
    real(8),        intent(out)   :: dist
    integer,        intent(out)   :: surface_crossed
    integer,        intent(out)   :: lattice_crossed

    integer :: i            ! index for surface in cell
    integer :: index_surf   ! index in surfaces array (with sign)
    real(8) :: x,y,z        ! particle coordinates
    real(8) :: u,v,w        ! particle directions
    real(8) :: d            ! evaluated distance
    real(8) :: x0,y0,z0     ! coefficients for surface
    real(8) :: r            ! radius for quadratic surfaces
    real(8) :: tmp          ! dot product of surface normal with direction
    real(8) :: a,b,c,k      ! quadratic equation coefficients
    real(8) :: quad         ! discriminant of quadratic equation
    logical :: on_surface   ! is particle on surface?
    type(Cell),       pointer, save :: cl => null()
    type(Surface),    pointer, save :: surf => null()
    type(Lattice),    pointer, save :: lat => null()
    type(LocalCoord), pointer, save :: coord => null()
    type(LocalCoord), pointer, save :: final_coord => null()
!$omp threadprivate(cl, surf, lat, coord, final_coord)

    ! inialize distance to infinity (huge)
    dist = INFINITY
    lattice_crossed = NONE
    nullify(final_coord)

    ! Get pointer to top-level coordinates
    coord => p % coord0

    ! Loop over each universe level
    LEVEL_LOOP: do while(associated(coord))

      ! get pointer to cell on this level
      cl => cells(coord % cell)

      ! copy directional cosines
      u = coord % uvw(1)
      v = coord % uvw(2)
      w = coord % uvw(3)

      ! =======================================================================
      ! FIND MINIMUM DISTANCE TO SURFACE IN THIS CELL

      SURFACE_LOOP: do i = 1, cl % n_surfaces

        ! copy local coordinates of particle
        x = coord % xyz(1)
        y = coord % xyz(2)
        z = coord % xyz(3)

        ! check for coincident surface -- note that we can't skip the
        ! calculation in general because a particle could be on one side of a
        ! cylinder and still have a positive distance to the other

        index_surf = cl % surfaces(i)
        if (index_surf == p % surface) then
          on_surface = .true.
        else
          on_surface = .false.
        end if

        ! check for operators
        index_surf = abs(index_surf)
        if (index_surf >= OP_DIFFERENCE) cycle

        ! get pointer to surface
        surf => surfaces(index_surf)

        ! TODO: Can probably combines a lot of the cases to reduce repetition
        ! since the algorithm is the same for (x-plane, y-plane, z-plane),
        ! (x-cylinder, y-cylinder, z-cylinder), etc.

        select case (surf % type)
        case (SURF_PX)
          if (on_surface .or. u == ZERO) then
            d = INFINITY
          else
            x0 = surf % coeffs(1)
            d = (x0 - x)/u
            if (d < ZERO) d = INFINITY
          end if

        case (SURF_PY)
          if (on_surface .or. v == ZERO) then
            d = INFINITY
          else
            y0 = surf % coeffs(1)
            d = (y0 - y)/v
            if (d < ZERO) d = INFINITY
          end if

        case (SURF_PZ)
          if (on_surface .or. w == ZERO) then
            d = INFINITY
          else
            z0 = surf % coeffs(1)
            d = (z0 - z)/w
            if (d < ZERO) d = INFINITY
          end if

        case (SURF_PLANE)
          A = surf % coeffs(1)
          B = surf % coeffs(2)
          C = surf % coeffs(3)
          D = surf % coeffs(4)

          tmp = A*u + B*v + C*w
          if (on_surface .or. tmp == ZERO) then
            d = INFINITY
          else
            d = -(A*x + B*y + C*w - D)/tmp
            if (d < ZERO) d = INFINITY
          end if

        case (SURF_CYL_X)
          a = ONE - u*u  ! v^2 + w^2
          if (a == ZERO) then
            d = INFINITY
          else
            y0 = surf % coeffs(1)
            z0 = surf % coeffs(2)
            r = surf % coeffs(3)

            y = y - y0
            z = z - z0
            k = y*v + z*w
            c = y*y + z*z - r*r
            quad = k*k - a*c

            if (quad < ZERO) then
              ! no intersection with cylinder

              d = INFINITY 

            elseif (on_surface) then
              ! particle is on the cylinder, thus one distance is
              ! positive/negative and the other is zero. The sign of k
              ! determines if we are facing in or out

              if (k >= ZERO) then
                d = INFINITY
              else
                d = (-k + sqrt(quad))/a
              end if

            elseif (c < ZERO) then
              ! particle is inside the cylinder, thus one distance must be
              ! negative and one must be positive. The positive distance
              ! will be the one with negative sign on sqrt(quad)

              d = (-k + sqrt(quad))/a

            else
              ! particle is outside the cylinder, thus both distances are
              ! either positive or negative. If positive, the smaller
              ! distance is the one with positive sign on sqrt(quad)

              d = (-k - sqrt(quad))/a
              if (d < ZERO) d = INFINITY

            end if
          end if

        case (SURF_CYL_Y)
          a = ONE - v*v  ! u^2 + w^2
          if (a == ZERO) then
            d = INFINITY
          else
            x0 = surf % coeffs(1)
            z0 = surf % coeffs(2)
            r = surf % coeffs(3)

            x = x - x0
            z = z - z0
            k = x*u + z*w
            c = x*x + z*z - r*r
            quad = k*k - a*c

            if (quad < ZERO) then
              ! no intersection with cylinder

              d = INFINITY 

            elseif (on_surface) then
              ! particle is on the cylinder, thus one distance is
              ! positive/negative and the other is zero. The sign of k
              ! determines if we are facing in or out

              if (k >= ZERO) then
                d = INFINITY
              else
                d = (-k + sqrt(quad))/a
              end if

            elseif (c < ZERO) then
              ! particle is inside the cylinder, thus one distance must be
              ! negative and one must be positive. The positive distance
              ! will be the one with negative sign on sqrt(quad)

              d = (-k + sqrt(quad))/a

            else
              ! particle is outside the cylinder, thus both distances are
              ! either positive or negative. If positive, the smaller
              ! distance is the one with positive sign on sqrt(quad)

              d = (-k - sqrt(quad))/a
              if (d < ZERO) d = INFINITY

            end if
          end if

        case (SURF_CYL_Z)
          a = ONE - w*w  ! u^2 + v^2
          if (a == ZERO) then
            d = INFINITY
          else
            x0 = surf % coeffs(1)
            y0 = surf % coeffs(2)
            r = surf % coeffs(3)

            x = x - x0
            y = y - y0
            k = x*u + y*v
            c = x*x + y*y - r*r
            quad = k*k - a*c

            if (quad < ZERO) then
              ! no intersection with cylinder

              d = INFINITY 

            elseif (on_surface) then
              ! particle is on the cylinder, thus one distance is
              ! positive/negative and the other is zero. The sign of k
              ! determines if we are facing in or out

              if (k >= ZERO) then
                d = INFINITY
              else
                d = (-k + sqrt(quad))/a
              end if

            elseif (c < ZERO) then
              ! particle is inside the cylinder, thus one distance must be
              ! negative and one must be positive. The positive distance
              ! will be the one with negative sign on sqrt(quad)

              d = (-k + sqrt(quad))/a

            else
              ! particle is outside the cylinder, thus both distances are
              ! either positive or negative. If positive, the smaller
              ! distance is the one with positive sign on sqrt(quad)

              d = (-k - sqrt(quad))/a
              if (d <= ZERO) d = INFINITY

            end if
          end if

        case (SURF_SPHERE)
          x0 = surf % coeffs(1)
          y0 = surf % coeffs(2)
          z0 = surf % coeffs(3)
          r = surf % coeffs(4)

          x = x - x0
          y = y - y0
          z = z - z0
          k = x*u + y*v + z*w
          c = x*x + y*y + z*z - r*r
          quad = k*k - c

          if (quad < ZERO) then
            ! no intersection with sphere

            d = INFINITY 

          elseif (on_surface) then
            ! particle is on the sphere, thus one distance is
            ! positive/negative and the other is zero. The sign of k
            ! determines if we are facing in or out

            if (k >= ZERO) then
              d = INFINITY
            else
              d = -k + sqrt(quad)
            end if

          elseif (c < ZERO) then
            ! particle is inside the sphere, thus one distance must be
            ! negative and one must be positive. The positive distance will
            ! be the one with negative sign on sqrt(quad)

            d = -k + sqrt(quad)

          else
            ! particle is outside the sphere, thus both distances are either
            ! positive or negative. If positive, the smaller distance is the
            ! one with positive sign on sqrt(quad)

            d = -k - sqrt(quad)
            if (d < ZERO) d = INFINITY

          end if

        case (SURF_CONE_X)
          x0 = surf % coeffs(1)
          y0 = surf % coeffs(2)
          z0 = surf % coeffs(3)
          r = surf % coeffs(4)

          x = x - x0
          y = y - y0
          z = z - z0
          a = v*v + w*w - r*u*u
          k = y*v + z*w - r*x*u
          c = y*y + z*z - r*x*x
          quad = k*k - a*c

          if (quad < ZERO) then
            ! no intersection with cone

            d = INFINITY 

          elseif (on_surface) then
            ! particle is on the cone, thus one distance is positive/negative
            ! and the other is zero. The sign of k determines which distance is
            ! zero and which is not.

            if (k >= ZERO) then
              d = (-k - sqrt(quad))/a
            else
              d = (-k + sqrt(quad))/a
            end if

          else
            ! calculate both solutions to the quadratic
            quad = sqrt(quad)
            d = (-k - quad)/a
            b = (-k + quad)/a

            ! determine the smallest positive solution 
            if (d < ZERO) then
              if (b > ZERO) then
                d = b
              end if
            else
              if (b > ZERO) d = min(d, b)
            end if
          end if

          ! If the distance was negative, set boundary distance to infinity
          if (d <= ZERO) d = INFINITY

        case (SURF_CONE_Y)
          x0 = surf % coeffs(1)
          y0 = surf % coeffs(2)
          z0 = surf % coeffs(3)
          r = surf % coeffs(4)

          x = x - x0
          y = y - y0
          z = z - z0
          a = u*u + w*w - r*v*v
          k = x*u + z*w - r*y*v
          c = x*x + z*z - r*y*y
          quad = k*k - a*c

          if (quad < ZERO) then
            ! no intersection with cone

            d = INFINITY 

          elseif (on_surface) then
            ! particle is on the cone, thus one distance is positive/negative
            ! and the other is zero. The sign of k determines which distance is
            ! zero and which is not.

            if (k >= ZERO) then
              d = (-k - sqrt(quad))/a
            else
              d = (-k + sqrt(quad))/a
            end if

          else
            ! calculate both solutions to the quadratic
            quad = sqrt(quad)
            d = (-k - quad)/a
            b = (-k + quad)/a

            ! determine the smallest positive solution 
            if (d < ZERO) then
              if (b > ZERO) then
                d = b
              end if
            else
              if (b > ZERO) d = min(d, b)
            end if
          end if

          ! If the distance was negative, set boundary distance to infinity
          if (d <= ZERO) d = INFINITY

        case (SURF_CONE_Z)
          x0 = surf % coeffs(1)
          y0 = surf % coeffs(2)
          z0 = surf % coeffs(3)
          r = surf % coeffs(4)

          x = x - x0
          y = y - y0
          z = z - z0
          a = u*u + v*v - r*w*w
          k = x*u + y*v - r*z*w
          c = x*x + y*y - r*z*z
          quad = k*k - a*c

          if (quad < ZERO) then
            ! no intersection with cone

            d = INFINITY 

          elseif (on_surface) then
            ! particle is on the cone, thus one distance is positive/negative
            ! and the other is zero. The sign of k determines which distance is
            ! zero and which is not.

            if (k >= ZERO) then
              d = (-k - sqrt(quad))/a
            else
              d = (-k + sqrt(quad))/a
            end if

          else
            ! calculate both solutions to the quadratic
            quad = sqrt(quad)
            d = (-k - quad)/a
            b = (-k + quad)/a

            ! determine the smallest positive solution 
            if (d < ZERO) then
              if (b > ZERO) then
                d = b
              end if
            else
              if (b > ZERO) d = min(d, b)
            end if
          end if

          ! If the distance was negative, set boundary distance to infinity
          if (d <= ZERO) d = INFINITY

        end select

        ! Check is calculated distance is new minimum
        if (d < dist) then
          if (abs(d - dist)/dist >= FP_PRECISION) then
            dist = d
            surface_crossed = -cl % surfaces(i)
            lattice_crossed = NONE
            final_coord => coord
          end if
        end if

      end do SURFACE_LOOP

      ! =======================================================================
      ! FIND MINIMUM DISTANCE TO LATTICE SURFACES

      if (coord % lattice /= NONE) then
        lat => lattices(coord % lattice)
        if (lat % type == LATTICE_RECT) then
          ! copy local coordinates
          x = coord % xyz(1)
          y = coord % xyz(2)
          z = coord % xyz(3)

          ! determine oncoming edge
          x0 = sign(lat % width(1) * 0.5_8, u)
          y0 = sign(lat % width(2) * 0.5_8, v)

          ! left and right sides
          if (abs(x - x0) < FP_PRECISION) then
            d = INFINITY
          elseif (u == ZERO) then
            d = INFINITY
          else
            d = (x0 - x)/u
          end if

          ! If the lattice boundary is coincident with the parent cell boundary,
          ! we need to make sure that the lattice is not selected. This is
          ! complicated by the fact that floating point may determine that one
          ! is closer than the other (can't check direct equality). Thus, the
          ! logic here checks whether the relative difference is within floating
          ! point precision.

          if (d < dist) then 
            if (abs(d - dist)/dist >= FP_REL_PRECISION) then
              dist = d
              if (u > 0) then
                lattice_crossed = LATTICE_RIGHT
              else
                lattice_crossed = LATTICE_LEFT
              end if
              final_coord => coord
            end if
          end if

          ! front and back sides
          if (abs(y - y0) < FP_PRECISION) then
            d = INFINITY
          elseif (v == ZERO) then
            d = INFINITY
          else
            d = (y0 - y)/v
          end if

          if (d < dist) then
            if (abs(d - dist)/dist >= FP_REL_PRECISION) then
              dist = d
              if (v > 0) then
                lattice_crossed = LATTICE_FRONT
              else
                lattice_crossed = LATTICE_BACK
              end if
              final_coord => coord
            end if
          end if

          if (lat % n_dimension == 3) then
            z0 = sign(lat % width(3) * 0.5_8, w)

            ! top and bottom sides
            if (abs(z - z0) < FP_PRECISION) then
              d = INFINITY
            elseif (w == ZERO) then
              d = INFINITY
            else
              d = (z0 - z)/w
            end if

            if (d < dist) then
              if (abs(d - dist)/dist >= FP_REL_PRECISION) then
                dist = d
                if (w > 0) then
                  lattice_crossed = LATTICE_TOP
                else
                  lattice_crossed = LATTICE_BOTTOM
                end if
                final_coord => coord
              end if
            end if
          end if

        elseif (lat % type == LATTICE_HEX) then
          ! TODO: Add hex lattice support
        end if
      end if

      coord => coord % next

    end do LEVEL_LOOP

    ! Move particle to appropriate coordinate level
    if (associated(final_coord)) p % coord => final_coord

  end subroutine distance_to_boundary

!===============================================================================
! SENSE determines whether a point is on the 'positive' or 'negative' side of a
! surface. This routine is crucial for determining what cell a particular point
! is in.
!===============================================================================

  recursive function sense(p, surf) result(s)

    type(Particle), intent(inout) :: p
    type(Surface),  pointer       :: surf   ! surface
    logical                       :: s      ! sense of particle

    real(8) :: x,y,z    ! coordinates of particle
    real(8) :: func     ! surface function evaluated at point
    real(8) :: A        ! coefficient on x for plane
    real(8) :: B        ! coefficient on y for plane
    real(8) :: C        ! coefficient on z for plane
    real(8) :: D        ! coefficient for plane
    real(8) :: x0,y0,z0 ! coefficients for quadratic surfaces / box
    real(8) :: r        ! radius for quadratic surfaces

    x = p % coord % xyz(1)
    y = p % coord % xyz(2)
    z = p % coord % xyz(3)

    select case (surf % type)
    case (SURF_PX)
      x0 = surf % coeffs(1)
      func = x - x0

    case (SURF_PY)
      y0 = surf % coeffs(1)
      func = y - y0

    case (SURF_PZ)
      z0 = surf % coeffs(1)
      func = z - z0

    case (SURF_PLANE)
      A = surf % coeffs(1)
      B = surf % coeffs(2)
      C = surf % coeffs(3)
      D = surf % coeffs(4)
      func = A*x + B*y + C*z - D

    case (SURF_CYL_X)
      y0 = surf % coeffs(1)
      z0 = surf % coeffs(2)
      r = surf % coeffs(3)
      y = y - y0
      z = z - z0
      func = y*y + z*z - r*r

    case (SURF_CYL_Y)
      x0 = surf % coeffs(1)
      z0 = surf % coeffs(2)
      r = surf % coeffs(3)
      x = x - x0
      z = z - z0
      func = x*x + z*z - r*r

    case (SURF_CYL_Z)
      x0 = surf % coeffs(1)
      y0 = surf % coeffs(2)
      r = surf % coeffs(3)
      x = x - x0
      y = y - y0
      func = x*x + y*y - r*r

    case (SURF_SPHERE)
      x0 = surf % coeffs(1)
      y0 = surf % coeffs(2)
      z0 = surf % coeffs(3)
      r = surf % coeffs(4)
      x = x - x0
      y = y - y0
      z = z - z0
      func = x*x + y*y + z*z - r*r

    case (SURF_CONE_X)
      x0 = surf % coeffs(1)
      y0 = surf % coeffs(2)
      z0 = surf % coeffs(3)
      r = surf % coeffs(4)
      x = x - x0
      y = y - y0
      z = z - z0
      func = y*y + z*z - r*x*x

    case (SURF_CONE_Y)
      x0 = surf % coeffs(1)
      y0 = surf % coeffs(2)
      z0 = surf % coeffs(3)
      r = surf % coeffs(4)
      x = x - x0
      y = y - y0
      z = z - z0
      func = x*x + z*z - r*y*y

    case (SURF_CONE_Z)
      x0 = surf % coeffs(1)
      y0 = surf % coeffs(2)
      z0 = surf % coeffs(3)
      r = surf % coeffs(4)
      x = x - x0
      y = y - y0
      z = z - z0
      func = x*x + y*y - r*z*z

    end select

    ! Check which side of surface the point is on
    if (abs(func) < FP_COINCIDENT) then
      ! Particle may be coincident with this surface. Artifically move the
      ! particle forward a tiny bit.
      p % coord % xyz = p % coord % xyz + TINY_BIT * p % coord % uvw
      s = sense(p, surf)
    elseif (func > 0) then
      s = .true.
    else
      s = .false.
    end if

  end function sense

!===============================================================================
! NEIGHBOR_LISTS builds a list of neighboring cells to each surface to speed up
! searches when a cell boundary is crossed.
!===============================================================================

  subroutine neighbor_lists()

    integer :: i          ! index in cells/surfaces array
    integer :: j          ! index of surface in cell
    integer :: i_surface  ! index in count arrays
    integer, allocatable :: count_positive(:) ! # of cells on positive side
    integer, allocatable :: count_negative(:) ! # of cells on negative side
    logical :: positive   ! positive side specified in surface list
    type(Cell),    pointer  :: c
    type(Surface), pointer  :: surf

    message = "Building neighboring cells lists for each surface..."
    call write_message(4)

    allocate(count_positive(n_surfaces))
    allocate(count_negative(n_surfaces))
    count_positive = 0
    count_negative = 0

    do i = 1, n_cells
      c => cells(i)

      ! loop over each surface specification
      do j = 1, c % n_surfaces
        i_surface = c % surfaces(j)
        positive = (i_surface > 0)
        i_surface = abs(i_surface)
        if (positive) then
          count_positive(i_surface) = count_positive(i_surface) + 1
        else
          count_negative(i_surface) = count_negative(i_surface) + 1
        end if
      end do
    end do

    ! allocate neighbor lists for each surface
    do i = 1, n_surfaces
      surf => surfaces(i)
      if (count_positive(i) > 0) then
        allocate(surf%neighbor_pos(count_positive(i)))
      end if
      if (count_negative(i) > 0) then
        allocate(surf%neighbor_neg(count_negative(i)))
      end if
    end do

    count_positive = 0
    count_negative = 0

    ! loop over all cells
    do i = 1, n_cells
      c => cells(i)

      ! loop over each surface specification
      do j = 1, c % n_surfaces
        i_surface = c % surfaces(j)
        positive = (i_surface > 0)
        i_surface = abs(i_surface)

        surf => surfaces(i_surface)
        if (positive) then
          count_positive(i_surface) = count_positive(i_surface) + 1
          surf%neighbor_pos(count_positive(i_surface)) = i
        else
          count_negative(i_surface) = count_negative(i_surface) + 1
          surf%neighbor_neg(count_negative(i_surface)) = i
        end if
      end do
    end do

    deallocate(count_positive)
    deallocate(count_negative)

  end subroutine neighbor_lists

!===============================================================================
! HANDLE_LOST_PARTICLE
!===============================================================================

  subroutine handle_lost_particle(p)

    type(Particle), intent(inout) :: p

    ! Print warning and write lost particle file
    call warning(force = .true.)
    call write_particle_restart(p)

    ! Increment number of lost particles
    p % alive = .false.
!$omp critical
    n_lost_particles = n_lost_particles + 1
!$omp end critical

    ! Abort the simulation if the maximum number of lost particles has been
    ! reached
    if (n_lost_particles == MAX_LOST_PARTICLES) then
      message = "Maximum number of lost particles has been reached."
      call fatal_error()
    end if

  end subroutine handle_lost_particle

  !===============================================================================
! DISTRIBCELL_OFFSET determines what cell a source particle is in within a 
! particular universe. If the base universe is passed, the particle should be 
! found as long as it's within the geometry. Found particles will have their 
! offset returned for a given distribcell filter. 
!===============================================================================

  recursive subroutine distribcell_offset(p, search_cells, found, offset)

    type(Particle), intent(inout) :: p
    integer,        intent(in)    :: search_cells(:) ! The list of cells from the filter, should be the user's inputted list
    logical,        intent(inout) :: found
    integer,        intent(inout) :: offset

    integer :: i                    ! index over cells
    integer :: j                    ! index over cells in filter
    integer :: k                    ! cell_dict key
    integer :: i_x, i_y, i_z        ! indices in lattice
    integer :: n_x, n_y, n_z        ! size of lattice
    integer :: n                    ! number of cells to search
    integer :: m                    ! number of cells to search in filter
    integer :: index_cell           ! index in cells array
    real(8) :: xyz(3)               ! temporary location
    real(8) :: upper_right(3)       ! lattice upper_right
    logical :: outside_lattice      ! if particle is not inside lattice bounds
    logical :: lattice_edge         ! if particle is on a lattice edge
    type(Cell),     pointer, save :: c => null()    ! pointer to cell
    type(Lattice),  pointer, save :: lat => null()  ! pointer to lattice
    type(Universe), pointer, save :: univ => null() ! universe to search in
!$omp threadprivate(c, lat, univ)

    ! Remove coordinates for any lower levels
    call deallocate_coord(p % coord % next)

    ! set size of list to search
    m = size(search_cells)
    
    univ => universes(p % coord % universe)
    n = univ % n_cells
    
    do i = 1, n
      ! select cells based on whether we are searching a universe or a provided
      ! list of cells (this would be for lists of neighbor cells)
      index_cell = univ % cells(i)
      
      ! get pointer to cell
      c => cells(index_cell)

      if (simple_cell_contains(c, p)) then
        ! Set cell on this level
        p % coord % cell = index_cell
        
        ! Show cell information on trace
        if (verbosity >= 10 .or. trace) then
          message = "    Entering cell " // trim(to_str(c % id))
          call write_message()
        end if

        ! add all the relevant offsets and check if this is one of the cells we plan to tally
        do j = 1, m
          ! need to know what index the cell is in the master array
          k = cell_dict % get_key(search_cells(j))
          offset = offset + c % offset(k)
          if (c % id == cells(k) % id) then
            found = .true.
          end if
        end do
        
        if (found) then
          return
        end if
        
        if (c % type == CELL_NORMAL) then
          ! ====================================================================
          ! AT LOWEST UNIVERSE, TERMINATE SEARCH

          ! set material
          p % last_material = p % material
          p % material = c % material

        elseif (c % type == CELL_FILL) then
          ! ====================================================================
          ! CELL CONTAINS LOWER UNIVERSE, RECURSIVELY FIND CELL

          ! Create new level of coordinates
          allocate(p % coord % next)
          p % coord % next % xyz = p % coord % xyz
          p % coord % next % uvw = p % coord % uvw

          ! Move particle to next level and set universe
          p % coord => p % coord % next
          p % coord % universe = c % fill

          ! Apply translation
          if (allocated(c % translation)) then
            p % coord % xyz = p % coord % xyz - c % translation
          end if

          ! Apply rotation
          if (allocated(c % rotation)) then
            p % coord % xyz = matmul(c % rotation, p % coord % xyz)
            p % coord % uvw = matmul(c % rotation, p % coord % uvw)
            p % coord % rotated = .true.
          end if

          call distribcell_offset(p, search_cells, found, offset)
          if (.not. found) exit

        elseif (c % type == CELL_LATTICE) then
          ! ====================================================================
          ! CELL CONTAINS LATTICE, RECURSIVELY FIND CELL

          ! Set current lattice
          lat => lattices(c % fill)

          outside_lattice = .false.
          lattice_edge = .false.

          ! determine lattice index based on position
          xyz = p % coord % xyz + TINY_BIT * p % coord % uvw
          i_x = ceiling((xyz(1) - lat % lower_left(1))/lat % width(1))
          i_y = ceiling((xyz(2) - lat % lower_left(2))/lat % width(2))
          n_x = lat % dimension(1)
          n_y = lat % dimension(2)
          if (lat % n_dimension == 3) then
            i_z = ceiling((xyz(3) - lat % lower_left(3))/lat % width(3))
            n_z = lat % dimension(3)
          else
            i_z = 1
            n_z = 1
          end if

          ! Check if lattice coordinates are within bounds
          if (i_x < 1 .or. i_x > n_x .or. i_y < 1 .or. i_y > n_y .or. &
               i_z < 1 .or. i_z > n_z) then

            ! Check for when particle is on lattice edge
            upper_right(1) = lat % lower_left(1) + &
                             lat % width(1) * dble(lat % dimension(1))
            upper_right(2) = lat % lower_left(2) + &
                             lat % width(2) * dble(lat % dimension(2))
            if ( abs(xyz(1) - lat % lower_left(1)) < FP_COINCIDENT .or. &
                 abs(xyz(2) - lat % lower_left(2)) < FP_COINCIDENT .or. &
                 abs(upper_right(1) - xyz(1)) < FP_COINCIDENT .or. &
                 abs(upper_right(2) - xyz(2)) < FP_COINCIDENT) then
              lattice_edge = .true.
            end if
            if (lat % n_dimension == 3) then
              upper_right(3) = lat % lower_left(3) + &
                               lat % width(3) * dble(lat % dimension(3))
              if (abs(xyz(3) - lat % lower_left(3)) < FP_COINCIDENT .or. &
                  abs(upper_right(3) - xyz(3)) < FP_COINCIDENT) then
                lattice_edge = .true.
              end if
            end if
            
            if (lattice_edge) then
              
              ! In this case the neutron is leaving the lattice, so we move it
              ! out, remove all lower coordinate levels and then search from
              ! universe 0.
            
              p % coord => p % coord0
              call deallocate_coord(p % coord % next)

              ! Reset surface and advance particle a tiny bit
              p % surface = NONE
              p % coord % xyz = xyz

            else

              ! We're outside the lattice, so treat this as a normal cell with
              ! the material specified for the outside

              outside_lattice = .true.
              p % last_material = p % material
              p % material = c % material

              ! We'll still make a new coordinate for the particle, as 
              ! distance_to_boundary will still need to track through lattice
              ! widths even though there's nothing in them but this material

            end if

          end if

          if (.not. lattice_edge) then

            ! Create new level of coordinates
            allocate(p % coord % next)

            ! adjust local position of particle
            p % coord % next % xyz(1) = p % coord % xyz(1) - &
                 (lat % lower_left(1) + (i_x - 0.5_8)*lat % width(1))
            p % coord % next % xyz(2) = p % coord % xyz(2) - &
                 (lat % lower_left(2) + (i_y - 0.5_8)*lat % width(2))
            if (lat % n_dimension == 3) then
              p % coord % next % xyz(3) = p % coord % xyz(3) - &
                 (lat % lower_left(3) + (i_z - 0.5_8)*lat % width(3))
            else
              p % coord % next % xyz(3) = p % coord % xyz(3)
            end if
            p % coord % next % uvw = p % coord % uvw

            ! set particle lattice indices
            p % coord % next% lattice   = c % fill
            p % coord % next% lattice_x = i_x
            p % coord % next% lattice_y = i_y
            p % coord % next% lattice_z = i_z
            if (.not. outside_lattice) then
              p % coord % next % universe = lat % universes(i_x,i_y,i_z)
            else

              ! Set universe as the same for subsequent calls to distribcell_offset
              p % coord % next % universe = p % coord % universe

              ! Set coord cell for calls to distance_to_boundary
              p % coord % next % cell = index_cell

            end if

            ! Move particle to next level
            p % coord => p % coord % next

          end if

          if (.not. outside_lattice) then
            
            ! add all the relevant offsets and check if this is one of the cells we plan to tally
            do j = 1, m
              ! need to know what index the cell is in the master array
              k = cell_dict % get_key(search_cells(j))
              offset = offset + lat % offset(k,i_x,i_y,i_z)
            end do
  
            call distribcell_offset(p, search_cells, found, offset)
            if (.not. found) exit
  
          end if

        end if

      end if
    end do

    found = .false.

  end subroutine distribcell_offset
  
  !===============================================================================
! CALC_OFFSETS calculates and stores the offsets in all cells
!===============================================================================

  recursive subroutine calc_offsets(i_vec, univ, cellid)

    integer, intent(in) :: i_vec
    type(Universe), intent(in) :: univ
    integer, intent(in) :: cellid

    integer :: i                    ! index over cells
    integer :: i_x, i_y, i_z        ! indices in lattice
    integer :: n_x, n_y, n_z        ! size of lattice
    integer :: n                    ! number of cells to search
    integer :: prevoffset           ! total offset for the previous cell
    integer :: tempoffset           ! total offset for a given cell
    integer :: index_cell           ! index in cells array
    integer :: index_univ           ! index to next universe in universes array
    real(8) :: xyz(3)               ! temporary location
    real(8) :: upper_right(3)       ! lattice upper_right
    type(Cell),     pointer :: c => null()    ! pointer to cell
    type(Lattice),  pointer :: lat => null()  ! pointer to lattice
    type(Universe), pointer :: univ_next => null() ! next universe to loop through

    n = univ % n_cells
    
    !print *, 'Uni ', univ % id , ' has ', n , ' cells'
    
    do i = 1, n
      
      index_cell = univ % cells(i)

      ! get pointer to cell
      c => cells(index_cell)
      tempoffset = 0
      call count_target_cell(c,cellid,tempoffset)
      
      
      if (i /= 1) then
      
        prevoffset = c % offset(i_vec)
      
      else
      
        prevoffset = 0
        c % offset = 0
        
      end if
       
      if (i /= n) then
      
        c => cells(index_cell + 1)
        c % offset(i_vec) = prevoffset + tempoffset
        c => cells(index_cell)
        
        !print *, 'Cell ', c % id , ' has offset ' , c % offset(i_vec)
      
      else 
        
        !print *, 'Cell ', c % id , ' has offset ' , c % offset(i_vec)
      
      end if           
      
      !print *, 'Cell type', c % type
      
      if (c % type == CELL_NORMAL) then
        ! ====================================================================
        ! AT LOWEST UNIVERSE, TERMINATE SEARCH

      elseif (c % type == CELL_FILL) then
        ! ====================================================================
        ! CELL CONTAINS LOWER UNIVERSE, RECURSIVELY FIND CELL

        univ_next => universes(c % fill)
        call calc_offsets(i_vec,univ_next,cellid)
        c => cells(index_cell)

      elseif (c % type == CELL_LATTICE) then
        ! ====================================================================
        ! CELL CONTAINS LATTICE, RECURSIVELY FIND CELL

        ! Set current lattice
        lat => lattices(c % fill)
        !print *, 'Lattice ', lat % id


        n_x = lat % dimension(1)
        n_y = lat % dimension(2)
        if (lat % n_dimension == 3) then
          n_z = lat % dimension(3)
        else
          n_z = 1
        end if
        !print *, 'Dimensions:',n_x,',',n_y,',',n_z
        ! Loop over lattice coordinates
        do i_x = 1, n_x
          do i_y = 1, n_y
            do i_z = 1, n_z

              univ_next => universes(lat % universes(i_x,i_y,i_z))
              
              tempoffset = 0
              if (i_x == 1 .AND. i_y == 1 .AND. i_z == 1) then
           
                lat % offset(i_vec,1,1,1) = 0
                prevoffset = 0
                call count_target_univ(univ_next,cellid,tempoffset)

              else
              
                prevoffset = lat % offset(i_vec,i_x,i_y,i_z)
                call count_target_univ(univ_next,cellid,tempoffset)
               
              end if
              

              if (i_z + 1 <= n_z) then
                lat % offset(i_vec,i_x,i_y,i_z+1) = tempoffset + prevoffset              
              elseif (i_y + 1 <= n_y) then
                lat % offset(i_vec,i_x,i_y+1,1) = tempoffset + prevoffset              
              elseif (i_x + 1 <= n_x) then
                lat % offset(i_vec,i_x+1,1,1) = tempoffset + prevoffset
              end if
              
              !print *, 'i:',i
              !print *, 'Lat',lat % id,' (',i_x,',',i_y,',',i_z,') has offset ' , lat % offset(i_vec,i_x,i_y,i_z)
              !print *, 'Precall Lat',lat % id
              call calc_offsets(i_vec,univ_next,cellid)
              c => cells(index_cell)
              lat => lattices(c % fill)
              !print *, 'Postcall Lat',lat % id
              !print *, 'Lat',lat % id,' (',i_x,',',i_y,',',i_z,') p2 has offset ' , lat % offset(i_vec,i_x,i_y,i_z)
            end do
          end do
        end do

      end if
    end do
    
    return
        
  end subroutine calc_offsets
  
!===============================================================================
! COUNT_TARGET_CELL recursively totals the numbers of occurances of a given cell id
! beginning with the cell given. Using -1 for the cell id will total all 
! normal cells.
!===============================================================================

  recursive subroutine count_target_cell(c, cellid, kount)

    type(Cell), intent(in) :: c
    integer, intent(in) :: cellid
    integer, intent(inout) :: kount

    integer :: i                    ! index over cells
    integer :: i_x, i_y, i_z        ! indices in lattice
    integer :: n_x, n_y, n_z        ! size of lattice
    integer :: n                    ! number of cells to search
    integer :: index_cell           ! index in cells array
    integer :: index_univ           ! index to next universe in universes array
    real(8) :: xyz(3)               ! temporary location
    real(8) :: upper_right(3)       ! lattice upper_right
    type(Cell),     pointer, save :: c_next => null()    ! pointer to cell
    type(Lattice),  pointer, save :: lat => null()  ! pointer to lattice
    type(Universe), pointer, save :: univ_next => null() ! next universe to loop through


    !print *, 'Cell ', c % id
    
    
    if (c % type == CELL_NORMAL) then
      ! ====================================================================
      ! AT LOWEST UNIVERSE, TERMINATE SEARCH
      if (cellid == c % id .OR. cellid == -1) then
        kount = kount + 1
      endif

    elseif (c % type == CELL_FILL) then
      ! ====================================================================
      ! CELL CONTAINS LOWER UNIVERSE, RECURSIVELY FIND CELL

      univ_next => universes(c % fill)
      
      n = univ_next % n_cells

      !print *, 'Uni ', univ_next % id , ' has ', n , ' cells'
      
      
      do i = 1, n
        !print *,'i:',i
        index_cell = univ_next % cells(i)

        ! get pointer to cell
        c_next => cells(index_cell)
        !print *, 'Cell ', c % id
        
        call count_target_cell(c_next, cellid, kount)
        univ_next => universes(c % fill)
        
      end do

    elseif (c % type == CELL_LATTICE) then
      ! ====================================================================
      ! CELL CONTAINS LATTICE, RECURSIVELY FIND CELL

      ! Set current lattice
      lat => lattices(c % fill)

      n_x = lat % dimension(1)
      n_y = lat % dimension(2)
      if (lat % n_dimension == 3) then
        n_z = lat % dimension(3)
      else
        n_z = 1
      end if
      
      ! Loop over lattice coordinates
      do i_x = 1, n_x
        do i_y = 1, n_y
          do i_z = 1, n_z

            !print *, 'Lattice (',i_x,',',i_y,',',i_z,')'
!              index_univ = universe_dict % get_key()
            univ_next => universes(lat % universes(i_x,i_y,i_z))
            
            n = univ_next % n_cells
    
            !print *, 'Uni ', univ_next % id , ' has ', n , ' cells'
            
            do i = 1, n
            
              index_cell = univ_next % cells(i)

              ! get pointer to cell
              c_next => cells(index_cell)
              !print *, 'Cell ', c % id
              
              call count_target_cell(c_next, cellid, kount)
              lat => lattices(c % fill)
              
            end do
            

          end do
        end do
      end do

    end if
    
  end subroutine count_target_cell

!===============================================================================
! COUNT_TARGET_UNIV recursively totals the numbers of occurances of a given cell id
! beginning with the universe given. Using -1 for the cell id will total all 
! normal cells.
!===============================================================================

  recursive subroutine count_target_univ(univ, cellid, kount)

    type(Universe), intent(in) :: univ
    integer, intent(in) :: cellid
    integer, intent(inout) :: kount

    integer :: i                    ! index over cells
    integer :: i_x, i_y, i_z        ! indices in lattice
    integer :: n_x, n_y, n_z        ! size of lattice
    integer :: n                    ! number of cells to search
    integer :: index_cell           ! index in cells array
    integer :: index_univ           ! index to next universe in universes array
    real(8) :: xyz(3)               ! temporary location
    real(8) :: upper_right(3)       ! lattice upper_right
    type(Cell),     pointer, save :: c => null()    ! pointer to cell
    type(Lattice),  pointer, save :: lat => null()  ! pointer to lattice
    type(Universe), pointer, save :: univ_next => null() ! next universe to loop through

    n = univ % n_cells
    !print *, 'univ:', univ % id
    do i = 1, n

      !print *, 'n_cells:', n
    
      index_cell = univ % cells(i)

      ! get pointer to cell
      c => cells(index_cell)
      
      !print *, 'Cell ', c % id
      
      
      !print *, 'Cell Type', c % type
      
      if (c % type == CELL_NORMAL) then
        ! ====================================================================
        ! AT LOWEST UNIVERSE, TERMINATE SEARCH
        if (cellid == c % id .OR. cellid == -1) then
          kount = kount + 1
        endif
        
      elseif (c % type == CELL_FILL) then
        ! ====================================================================
        ! CELL CONTAINS LOWER UNIVERSE, RECURSIVELY FIND CELL

        !print *, 'Fill Cell '
        univ_next => universes(c % fill)
        call count_target_univ(univ_next,cellid,kount)
        c => cells(index_cell)

      elseif (c % type == CELL_LATTICE) then
        ! ====================================================================
        ! CELL CONTAINS LATTICE, RECURSIVELY FIND CELL

        ! Set current lattice
        lat => lattices(c % fill)
        
        n_x = lat % dimension(1)
        n_y = lat % dimension(2)
        if (lat % n_dimension == 3) then
          n_z = lat % dimension(3)
        else
          n_z = 1
        end if
        
        ! Loop over lattice coordinates
        do i_x = 1, n_x
          do i_y = 1, n_y
            do i_z = 1, n_z
              !print *, 'Lattice (',i_x,',',i_y,',',i_z,')'
              univ_next => universes(lat % universes(i_x,i_y,i_z))
              call count_target_univ(univ_next,cellid,kount)
              c => cells(index_cell)
              lat => lattices(c % fill)
              
            end do
          end do
        end do

      end if
    end do
             
  end subroutine count_target_univ


end module geometry
